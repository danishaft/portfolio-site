{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-how-computers-work-index-mdx","path":"/articles/2025/how-computers-work/","result":{"data":{"mdx":{"id":"7cea56c6-3179-546c-91bc-47010a3a0a6d","body":"\nI use computers every day. You probably do too. But if someone asked me to explain how they really work, the high-level understanding I have would not suffice. I've been writing code for years now. But the gap between typing a command and pixels lighting up? Total mystery.ü§î\n\nSo I went down the rabbit hole. I spent more time researching, watching videos, and piecing together explanations from a dozen sources. It turned out to be surprisingly fun and more rewarding than I expected. Once you have the right frame, it's not hard to understand.\n\nAt the core, every computer is simply an electronic machine that takes in input data (keyboard presses, mouse clicks, voice commands, etc.), stores it (short-term or long-term in registers, hard drives, RAM, etc.), processes it (using the CPU), and outputs results in some form (displaying text and images on the monitor, sound via speakers, network packets, etc.).\n\nHere's the thing: computers are built on **layers of abstraction.** Each layer, from hardware, firmware, operating system, programming language, and application, hides the complexity beneath it. When you write code or use a website, you don't think about transistors or voltage levels or how the CPU decodes instructions. You just call functions. The layers beneath handle the rest.\n\nIn this article, I'll focus on Storage and Processing, the parts that happen inside the computer and remain mysterious to most of us. The computer turns your input actions into signals and instructions, and the result is something you can interact with. The real question is where those signals and instructions live when they're inside, and how the computer transforms them? We'll unravel all of that.\n\n![Concentric circles diagram showing computer abstraction layers from innermost to outermost: Hardware, Firmware, Operating System, Programming Languages, and Applications](./assets/02-abstraction-layers.webp)\n\n**_Image:_** _A concentric ring or pyramid diagram showing the layer of abstraction progression from_ **_Hardware_** _‚Üí_ **_OS_** _‚Üí_ **_Applications_**_._\n\n## The Language: Why Binary and How Bits Encode Everything\n\nComputers don't see the world the way we do. At the most basic level, they only speak binary: a language of 1s and 0s.üíª Each 1 or 0 is called a **bit** (short for binary digit), and it's the fundamental unit of information. This means that every input or output, including every photo, song, video, email, and program you've ever interacted with, gets translated into or from binary data.\n\nModern computers are digital. They don't just relay information. They give electrical signals meaning. A signal under a certain voltage threshold is interpreted as \"off\" (0), and over a certain threshold is \"on\" (1). The continuous voltage range is reduced to just two discrete states. This is where the term \"digital\" originates: from the digits 0 and 1.\n\nYou might wonder why computers use only two values (0 and 1) instead of ten, like our decimal number system (0 to 9). The answer is that two states are much easier to tell apart reliably. When you're working with electrical signals, noise and variations are inevitable. With just two distinct states, one representing 0 and the other representing 1, there's no ambiguity, even when conditions aren't perfect. More states would mean more confusion, more errors, more complexity.\n\nBinary works just like decimal, except with powers of two. For example, 01001000 in binary equals 72 in decimal. This value represents the letter 'H' in ASCII, a standard whose first 128 characters are directly adopted by Unicode.\n\nWith 8 bits (a byte), you can represent 256 possible values (2^8 = 256, ranging from 0 to 255). Combine enough bits, and you can represent anything: numbers, letters, images, sound, video. What makes that possible are standards. The computer doesn't \"know\" what 'H' is. It just follows agreed-upon rules like Unicode for text, RGB for images, or WAV for sound.\n\nNow, since everything boils down to numbers, how do we store something like a song or a video? Through encoding standards like MP4 for video or JPEG for images, these get converted to numbers that the computer can store and manipulate.\n\nEverything inside the computer, everything Storage holds, and everything Processing touches, is built on this foundation of 1s and 0s. But those bits are not abstract ideas. They're physical voltages controlled by billions of switches working together. Let's see how\n\n## The Hardware: From Silicon to Logic\n\nNow let's descend to the hardware layer and talk about how the computer physically creates those 1s and 0s using electricity, and how it uses them to make decisions and perform operations. Remember those binary digits we just discussed? Here's how they physically exist inside the machine.\n\n### The Motherboard\n\nInside your computer case, you'll find many things: a power supply, cooling fans, storage drives, and various cables connecting everything together. But **most of the action takes place on the motherboard**, the main circuit board of the computer, so that's where we'll focus.\n\nThe motherboard is a printed circuit board (PCB), a flat board with copper wires etched into it, connecting various components. The board can have multiple layers for efficient signal routing.\n\nThe key innovation for modern computers is the integrated circuit (IC), commonly called a chip or microchip. An IC is essentially a complete electronic circuit etched onto a single piece of silicon. This allows billions of tiny components called transistors to be packed onto a chip smaller than your fingernail.\n\nKey components on the motherboard:\n\n- **The CPU (Central Processing Unit)** - A single chip that plugs into a socket on the motherboard. This is where all the processing happens. Inside the CPU are several specialized components working together: a **control unit** that orchestrates everything, an **ALU** that performs calculations, tiny fast memory locations called **registers**, and small pools of ultra-fast memory called **cache**.\n- **RAM (Random Access Memory)** - Memory sticks that slot into the motherboard. This is the fast, temporary storage for data that the computer is actively working on.\n- **Chipset** - A set of chips that manage data flow between the CPU, memory, and peripheral devices. Think of it as the motherboard's traffic controller, coordinating communication between all the major components.\n- **BIOS/UEFI chip** - Stores firmware (the low-level software layer between hardware and the operating system) that runs when you first turn on the computer. This firmware performs hardware checks and loads the operating system from storage.\n- **Ports** - USB ports, network ports, etc., that connect external devices.\n\n![Labeled diagram of a computer motherboard showing key components including CPU socket, RAM slots, chipset, PCIe slots, SATA ports, and I/O ports](./assets/03-motherboard.webp)\n\n**_Image:_** _Motherboard layout showing the main circuit board with key components like the CPU socket, RAM slots, chipset, and ports._\n\n**We'll focus on what happens inside the CPU chip, because that's where processing happens.**\n\n### Inside the CPU: Transistors and Gates\n\nUnder the hood, bits are voltages. In modern circuits, a \"high\" voltage encodes 1, a \"low\" voltage encodes 0. Numbers are literally voltage levels flowing through wires. The component responsible for controlling these voltages is called a **transistor**, an electrically controlled switch that's the fundamental building block of all digital electronics.\n\nThe type used in modern CPUs is called a MOSFET (Metal-Oxide-Semiconductor Field-Effect Transistor). Apply voltage to the control? Current flows. Switch ON. Remove voltage? Current stops. Switch OFF.\n\nA modern processor can pack tens of billions of transistors into a chip the size of your fingernail. Apple's M3 chips, for example, contain over 90 billion transistors ü§Ø, each one flipping on and off billions of times per second.\n\nWiring these transistors in specific patterns creates **logic gates**. Gates are tiny circuits that implement rules. They take voltage inputs (1s and 0s) and produce voltage outputs based on logical operations, like AND gates that only output 1 when both inputs are 1, or NOT gates that flip their input.\n\nCombine enough of these gates, and you can build something far greater: the **ALU (Arithmetic Logic Unit)**‚Äîthe part of your CPU that adds, subtracts, compares numbers, and performs logical operations. All computer math happens here. Want to add two numbers? The ALU chains together XOR gates and AND gates in a specific pattern called an adder circuit. But there's a subtle problem lurking here.\n\n### The Clock: Keeping Everything in Sync\n\nHere's something interesting about voltage. It takes time to ripple through gates. Send a signal through one gate, and it might take a nanosecond to stabilize. Chain thousands of gates together and you've got signals arriving at different times, some still changing while others have already settled. Without coordination, it's chaos. Results would be corrupted mid-flight. Outputs would be garbage.\n\nThat's where the **clock** comes in. Think of the clock like an orchestra conductor üéµ keeping all the musicians in time. A CPU's clock ticks billions of times per second (measured in GHz, a 3.5 GHz CPU ticks 3.5 billion times per second). The clock generates consistent electrical pulses sent down the wires. It does this the same way a digital watch keeps time: using a quartz crystal that vibrates at a precise frequency when electricity is applied.\n\n**Between ticks:** Voltages propagate through gates. Computation is happening, signals are flowing, and math is being done.\n\n**On each tick:** Results get locked into place (stored in small memory circuits) so the next stage can start fresh with stable values.\n\nThe clock remains the fundamental heartbeat that synchronizes everything and keeps electrons marching in formation.\n\nSo now we have transistors that can switch on and off to represent 1s and 0s. We have gates that use those switches to make decisions. We have an ALU that chains gates together to do math. And we have a clock that keeps everything synchronized. That's processing. But processing is useless without somewhere to put the data.\n\n## Memory: Where Data Lives\n\nMoving up a layer, we need to understand where data lives. Processing is only half the story. The CPU needs somewhere to store the data it's working on, and not all storage is created equal. Modern computers use a **memory hierarchy**, balancing trade-offs between speed, size, and cost. Think of memory like a pyramid:\n\n![Pyramid diagram illustrating computer memory hierarchy from top to bottom: Registers (fastest, smallest), Cache L1/L2/L3, RAM (middle ground), and Storage/Hard Drives (slowest, largest)](./assets/04-memory-hierarchy.webp)\n\n**_Image:_** _A pyramid diagram illustrating the memory hierarchy, showing the trade-off in speed, size, and cost. It progresses from the fastest layer Registers at the top, through Cache L1/L2/L3 and RAM, to Storage the largest layer at the bottom._\n\n**At the top (fastest, smallest, most expensive):**\n\n- **Registers** - Tiny storage locations inside the CPU itself. A CPU might have only a few dozen registers, each holding a single number (typically 64 bits). These are where the CPU keeps the data it's using _right now_. There are general-purpose registers for holding any data, and special-purpose registers like the **program counter** which tracks which instruction to execute next and the **instruction register** which holds the current instruction being processed.\n- **Cache** - Small, fast memory also very close to the CPU. Split into levels: L1 (smallest, fastest, typically per-core), L2 (bigger, slower, also per-core in modern CPUs), L3 (bigger still, slower still, usually shared across all cores). Modern CPUs might have 256 KB of L1 per core, 1-8 MB of L2 per core, and 8-64 MB of shared L3.\n\n**In the middle:**\n\n- **RAM (Random Access Memory)** - The main working memory. Your computer might have 8, 16, or 32 GB of RAM. Much larger than cache, but slower to access.\n\n**At the bottom (slowest, largest, cheapest):**\n\n- **Storage** - SSDs and hard drives. Terabytes of space, but thousands of times slower than RAM.\n\nThis hierarchy exists because of physics and economics. You can't make infinite amounts of super-fast memory, it's expensive and generates too much heat. So computers keep a little bit of ultra-fast memory close to the CPU and larger pools of slower memory further away. But how do these different types of memory actually work, and how does data move between them?\n\n### Connecting CPU and RAM: Buses\n\nBefore I show you how memory works, remember that data doesn't magically move; it travels along wires grouped into **buses** (they \"transport\" information, like a bus transports passengers).\n\nThere are two critical buses connecting the CPU and RAM:\n\n- **Address bus:** The CPU sends memory addresses along this bus to tell RAM which location it wants to access. Think of it like telling a librarian which book you want by giving them the call number.\n- **Data bus:** The actual data travels back and forth along this bus. This is typically 64 bits wide (64 wires running in parallel), allowing 64 bits to transfer simultaneously.\n\nWhen the CPU needs data from RAM, it sends the address on the address bus, and RAM responds by sending the data back on the data bus. This communication takes time, hundreds of clock cycles. This is why the memory hierarchy exists: to keep frequently used data closer.\n\n### RAM: The Active Workspace\n\nThe most common type of RAM is **DRAM (Dynamic RAM)**. Each bit is stored as a tiny electric charge in a capacitor. If the capacitor is charged, that's a 1. If it's empty, that's a 0.\n\nReading the charge tells you the bit's value, but reading is destructive, it discharges the capacitor, which must be recharged. Additionally, capacitors naturally leak charge over time, so RAM constantly refreshes itself thousands of times per second. This is why it's called _Dynamic_ RAM.\n\nHere's the catch: DRAM is **volatile memory** because it requires constant power to maintain data. When you turn off the power, the capacitors lose their charge, and everything in RAM disappears. That's why you have to save your work to disk which uses non-volatile memory that retains data without power, like SSDs using flash memory or traditional hard drives using magnetic storage.\n\nCache and registers use a different technology: **SRAM (Static RAM)**. Instead of capacitors, SRAM uses circuits made from transistors wired in a configuration that holds its state as long as power flows, no constant refreshing is needed. The same transistors that make logic gates can also be configured to store values. This makes SRAM much faster than DRAM, but also much more expensive and physically larger for the same amount of storage. That's why you only get megabytes of cache versus gigabytes of RAM.\n\n### Persistent Storage: Data That Lasts\n\nRAM is fast but forgets everything when you power off. For data that needs to survive, computers use persistent storage like hard drives and SSDs.\n\n**Hard Disk Drives (HDDs)** store data using magnetism. Inside are spinning metal platters with a tiny head floating above them like a record player. The head magnetizes microscopic spots on the disk, one direction is 1, the opposite is 0. Reading just detects those magnetic fields.\n\nThe problem? Moving parts. The head has to physically swing to the right location, and the platter has to spin to the right spot. That takes time. Millions of clock cycles. But HDDs are cheap and can store terabytes.\n\n**SSDs** use flash memory, a special type of transistor with an extra \"floating gate\" that can trap electrons. Force electrons onto that gate, and they stay there even without power. That's your 1. No electrons? That's 0. Reading just checks if charge is trapped.\n\nNo moving parts means SSDs are significantly faster than HDDs. They're also more expensive per gigabyte, but for speed, nothing beats them.\n\nModern computers often use both: SSD for the OS and programs, HDD for bulk storage.\n\n### Why Location Matters\n\nHere's a quick example: Let's say the CPU needs to add two numbers.\n\n- If the numbers are in registers: 1-2 clock cycles. Nearly instant.‚ö°\n- If they're in L1 cache: 4 cycles.\n- If they're in L3 cache: 40 cycles.\n- If they're in RAM: 200 cycles.\n- If they're on disk: Millions of cycles.üêå\n\nThis is why good software always tries to keep frequently-used data \"close\" to the CPU. This principle is called **locality of reference**. If the CPU just used a piece of data, it'll probably need it again soon, so keep it in cache. Modern CPUs are smart about this. They automatically predict what data you'll need next and pre-load it into cache. When they guess right, your program is faster. When they guess wrong, you wait.\n\nNow here's where it all comes together. We've got transistors and gates that can compute. We've got memory that can store data at different speeds. But how does the CPU orchestrate all of these to actually run a program?\n\n## Processing: How the CPU Executes Instructions\n\nWe've seen the building blocks, transistors, gates, and memory. Now, let's explore how the CPU actually runs a program.\n\n### The Instruction Cycle\n\nEvery program is a list of instructions stored in RAM. Each instruction is just a number; some bits describe the operation (add, subtract, load, store), and other bits point to where the data lives in memory. The CPU runs these instructions one at a time in a loop called the **instruction cycle** also called the **fetch-decode-execute cycle**.\n\n![Flow diagram showing the CPU instruction cycle: arrows connecting RAM to Instruction Register to Control Unit, which coordinates with ALU and Registers, with results flowing back to RAM](./assets/05-fetch-decode-execute.webp)\n\n**_Image:_** _A flow visualization of the_ **_fetch-decode-execute cycle_**_, showing how instructions flow from_ **_RAM_** _to the_ **_instruction register_**_, through the_ **_control unit_** _and_ **_ALU/registers_**_, and back to memory._\n\nIt's worth noting that different CPUs use different instruction sets (called ISAs)‚Äîx86-64, ARM, RISC-V, etc. Each has its own binary encoding, which is why software compiled for one processor won't run on another without translation.\n\n### Putting It All Together\n\nHere's a simple example. Imagine a program that adds two numbers and stores the result. In assembly language (a human-readable version of machine code), it'll look like this:üëá\n\n```asm\nLOAD R1, [1000]   ; Load the value at memory address 1000 into register R1\nLOAD R2, [1004]   ; Load the value at memory address 1004 into register R2\nADD R3, R1, R2    ; Add R1 and R2, store result in R3\nSTORE R3, [1008]  ; Store R3's value back to memory address 1008\n```\n\n**What the CPU does:**\n\n1. **Fetch** the first instruction from RAM\n2. **Decode** it: \"LOAD means get data from memory\"\n3. **Execute**: Send address 1000 to RAM, get back the value, and put it in register R1\n4. Move to the next instruction, repeat for R2\n5. **Fetch** the ADD instruction\n6. **Decode**: \"ADD means use the ALU\"\n7. **Execute**: The ALU takes values from R1 and R2, adds them using XOR and AND gate circuits, and puts the result in R3\n8. **Fetch** the STORE instruction\n9. **Execute**: Send R3's value to RAM at address 1008\n\nEach step is just voltages changing, gates opening and closing, electrons flowing through silicon. But layer enough of these steps together, and you get everything a computer can do.\n\nModern CPUs do clever tricks to go faster: they fetch the next instruction while decoding the current one (called **pipelining**), they execute multiple instructions at once on different parts of the chip (called **superscalar execution**), and they run multiple programs simultaneously on different **cores** (multiple CPUs on one chip). But the fundamental cycle‚Äîfetch, decode, execute, is always there, happening millions of times in the blink of an eye.\n\n## The Conductor: How the OS Brings It All Together\n\nWe've covered most of storage and processing, the core of how computers work. But there's one more piece needed to make this all useful: something has to coordinate everything we've discussed.\n\nThat's where the **operating system** comes in. Think of it as the conductor of the orchestra we've been building.\n\nYou're probably running dozens of programs right now. Your browser, music player, and text editor, they're all loaded in RAM, all waiting for CPU time. The OS manages this by giving each program a tiny slice of CPU time, maybe 10 milliseconds, then switching to the next program. It happens so fast you don't notice. This is **multitasking** in play.üîÑ\n\nThe OS also protects programs from each other. Each program thinks it has full access to RAM, but the OS carves up memory into protected sections. If one program crashes, it can't corrupt another's data. A piece of hardware called the MMU (Memory Management Unit) works with the OS to implement virtual memory, where each program gets its own isolated address space. The MMU translates these virtual addresses to actual physical RAM addresses. When RAM fills up, the OS can even move unused data to disk (called paging or swapping), making programs think there's more RAM than physically exists, though accessing this disk-backed memory is much slower than real RAM as we now know.\n\nWhen your program needs to talk to hardware,display something on screen, save a file, or send data over the network, it doesn't do it directly. It asks the OS through a **system call**, and the OS handles the details using **device drivers** that know how to communicate with specific hardware.\n\nThis layering means you can write code that says \"save this file\" without knowing anything about how your SSD controller works. The OS translates your high-level request into the low-level commands that storage hardware understands.\n\n## Conclusion\n\nSo, how do computers actually work?\n\nAt the bottom, billions of transistors switch on and off, representing 1s and 0s as voltage levels. Move one layer up, and logic gates combine those 1s and 0s into decisions, building up to ALUs that perform math using adder circuits and flags. Another layer up, the memory hierarchy balances speed and size‚Äîregisters, cache, RAM, and storage each serve data at different speeds, connected by buses. Another layer up, the CPU executes its cycle: fetch, decode, execute, all synchronized by a clock ticking thousands of times per millisecond. One more layer, and the OS orchestrates it all, managing programs, protecting memory, and coordinating hardware. At the top sits your code, blissfully unaware of the intricate dance playing out below.\n\nRemember when I said the gap between typing a command and pixels lighting up was a total mystery? Now you know: your keypress becomes a voltage signal, travels through buses, gets stored as charges in RAM, triggers CPU instructions fetched from memory, executed by billions of transistors arranged in logic gates, all synchronized by a clock ticking billions of times per second, with the result written back to memory and sent to your graphics card to light up specific pixels. What once seemed like magic is now just... Well, really pretty clever engineering.‚ú®\n\nDoes understanding all this make you a better programmer? Maybe not directly. But there's something deeply satisfying about knowing how these various components make up the computer. And that, I think, is pretty remarkable.\n\nHere's a list of amazing resources I've found while doing some research for this post:üôÇüìö\n\n- **[Crash Course Computer Science: Episodes 5, 7 and 17](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)** - Good resource on CPU operations, memory hierarchy, and instruction cycles\n- **[Intro to Truth Tables & Boolean Algebra | by Brett Berry | Math Hacks | Medium](https://medium.com/i-math/intro-to-truth-tables-boolean-algebra-73b331dd9b94)** - An introduction to Logic and Truth Tables\n- **[See How a CPU Works - In One Lesson](https://www.youtube.com/watch?v=cNN_tTXABUA)** - A Visual demonstration of fetch-decode-execute cycle\n- **[How Motherboards Work - HowStuffWorks](https://computer.howstuffworks.com/motherboard.htm)** - Motherboard components and PCB structure\n- **[Why You Can't Use CPU Clock Speed to Compare Computer Performance - How-To Geek](https://www.howtogeek.com/394678/why-you-cant-use-cpu-clock-speed-to-compare-computer-performance/)** - An intro to Clock speed and CPU performance factors\n- **[How do hard drives work? - TED-Ed](https://ed.ted.com/lessons/how-do-hard-drives-work-kanawat-senanan)** - A deep dive into HDD magnetic storage mechanism\n- **[Computer memory - Wikipedia](https://en.wikipedia.org/wiki/Computer_memory)** - Comprehensive coverage of RAM, cache, registers, SRAM vs DRAM\n- **[Stack Exchange - Flash Memory](https://electronics.stackexchange.com/questions/tagged/flash-memory)** - SSD flash memory technology and floating gates\n","fields":{"slug":"/articles/2025/how-computers-work/"},"internal":{"contentFilePath":"/home/runner/work/portfolio-site/portfolio-site/src/posts/2025/how-computers-work/index.mdx"},"frontmatter":{"title":"Understanding How Computers Actually Work","summary":"A deep dive into how computers work from the ground up‚Äîfrom binary and transistors to logic gates, CPU cycles, memory hierarchy, and operating systems.","date":"01 November, 2025","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#d8e8e8","images":{"fallback":{"src":"/static/4a1fc8502ec1b270769ec3726b341089/1ad5b/01-cover.webp","srcSet":"/static/4a1fc8502ec1b270769ec3726b341089/c29f3/01-cover.webp 750w,\n/static/4a1fc8502ec1b270769ec3726b341089/1ad5b/01-cover.webp 1000w","sizes":"100vw"},"sources":[]},"width":1,"height":0.42}}}}}},"pageContext":{"slug":"/articles/2025/how-computers-work/","frontmatter":{"title":"Understanding How Computers Actually Work","summary":"A deep dive into how computers work from the ground up‚Äîfrom binary and transistors to logic gates, CPU cycles, memory hierarchy, and operating systems.","cover":"assets/01-cover.webp","date":"2025-11-01T00:00:00.000Z"}}},"staticQueryHashes":[],"slicesMap":{}}