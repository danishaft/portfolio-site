"use strict";(self.webpackChunkgatsby_starter_default=self.webpackChunkgatsby_starter_default||[]).push([[529],{5914:function(n,a,s){s.r(a),s.d(a,{default:function(){return l}});var e=s(8453),t=s(6540);function p(n){const a=Object.assign({p:"p",a:"a",strong:"strong",span:"span",h2:"h2",h3:"h3",ol:"ol",li:"li",ul:"ul",em:"em"},(0,e.RP)(),n.components);return t.createElement(t.Fragment,null,t.createElement(a.p,null,t.createElement(a.a,{href:"https://react.dev/reference/react"},"React Hooks")," have revolutionized how we manage logic and side effects in functional components, but two hooks‚Äî",t.createElement(a.a,{href:"https://react.dev/reference/react/useCallback"},"useCallback")," and ",t.createElement(a.a,{href:"https://react.dev/reference/react/useMemo"},"useMemo"),"‚Äîare frequently misunderstood and overused in the process of obsessively trying to memoise."),"\n",t.createElement(a.p,null,"This article explains when memoisation actually helps, when it's counterproductive, and which modern alternatives provide better solutions."),"\n",t.createElement(a.p,null,"Why do we memoise in the first place? In React, more often than not, we decide to create a memoised version of a value with ",t.createElement(a.strong,null,"useMemo")," or a memoised function with ",t.createElement(a.strong,null,"useCallback")," in order to skip re-rendering a sub-tree. Now re-rendering a sub-tree is usually slow in React, so we'll prefer to skip any unnecessary re-renders. In order to optimise performance, we mostly reach out for ",t.createElement(a.a,{href:"https://react.dev/reference/react/memo"},t.createElement(a.strong,null,"React.memo"))," to skip re-rendering a component when its props are unchanged."),"\n",t.createElement(a.p,null,"Here's the catch: when we pass a function or a non-primitive value as props to this memoised component, we need to make sure they have stable references. Before React skips re-rendering a sub-tree, it first compares the props of the memoised component to ascertain if they have changed. So if our props always have unstable references, the value of optimisation is lost because then our memoised component will not get memoised at the end of the day."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Nah</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MemoizedComponent</span></span>\n      <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token literal-property property">hello</span><span class="token operator">:</span> <span class="token string">\'world\'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></span> <span class="token comment">// New object reference each render</span>\n      <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'result\'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token comment">// New function reference each render</span>\n    <span class="token punctuation">/></span></span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">Okay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">hello</span><span class="token operator">:</span> <span class="token string">\'world\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> onChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MemoizedComponent</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onChange<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"This is just one of the reasons we try to memoise; another reason is to prevent effects from firing too often. When you pass a prop as a dependency to an effect, React does the same thing it does: it compares the dependency to ascertain if the effect needs to be re-run. In all of these, React is trying to do the same thing, which is to keep the references stable by caching them. So it's normal that useCallback and useMemo always come through for this reason."),"\n",t.createElement(a.h2,{id:"when-memoisation-fails",style:{position:"relative"}},"When Memoisation Fails",t.createElement(a.a,{href:"#when-memoisation-fails","aria-label":"when memoisation fails permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"When memoisation isn't solving one of the two problems mentioned above, it becomes useless noise. So there are cases where striving for stability in references is important, and there are others where it's pointless. Let's see some cases where the use of ",t.createElement(a.strong,null,"useCallback")," and ",t.createElement(a.strong,null,"useMemo")," becomes redundant:"),"\n",t.createElement(a.h3,{id:"case-1-memoising-unmemoized-components-zero-performance-gain",style:{position:"relative"}},"Case 1: Memoising Unmemoized Components (Zero Performance Gain)",t.createElement(a.a,{href:"#case-1-memoising-unmemoized-components-zero-performance-gain","aria-label":"case 1 memoising unmemoized components zero performance gain permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"The common mistake is using ",t.createElement(a.strong,null,"useCallback")," or ",t.createElement(a.strong,null,"useMemo")," on a prop being passed to an unmemoized functional component or a React built-in component like a button."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Okay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">hello</span><span class="token operator">:</span> <span class="token string">\'world\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> onChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onChange<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"Now it's important to note that the custom component and the button don't care if the props have stable references. So if your custom component is not memoised using React.memo, it really doesn't care about your referential stability. You gain no performance improvement while introducing unnecessary boilerplate."),"\n",t.createElement(a.h3,{id:"case-2-the-broken-dependency-chain",style:{position:"relative"}},"Case 2: The Broken Dependency Chain",t.createElement(a.a,{href:"#case-2-the-broken-dependency-chain","aria-label":"case 2 the broken dependency chain permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"It's rarely a good idea to add non-primitive props like objects or functions to your dependency arrays. Why? Because your component has no control over whether the parent keeps those references stable."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">NotOkay</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onChange <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> handleChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">e</span><span class="token operator">:</span> React<span class="token punctuation">.</span>ChangeEvent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">trackAnalytics</span><span class="token punctuation">(</span><span class="token string">\'changeEvent\'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>\n    onChange<span class="token operator">?.</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>onChange<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SomeMemoizedComponent</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"This useCallback is not useful in this context, or at best, it depends on how consumers will use this component. In all likelihood, there is a call-side that just invokes an inline function:"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">NotOkay</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> props<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"The parent's unstable prop reference forces the child's useCallback to invalidate its cache on every render. The only way a developer who writes this code could know that not wrapping the prop in useCallback themselves breaks some internal memoisation is if they drill down into the component to see how the props are being used."),"\n",t.createElement(a.p,null,"That's a horrible developer experience. üò∞ The only other popular option will be to memoise everything, always reach out for useCallback and useMemo, but these aren't great practices, but rather create overhead under the hood."),"\n",t.createElement(a.p,null,"Now, let's examine a real-world example that demonstrates why excessive memoisation becomes problematic. Even in well-architected codebases, I've seen cascading memoisation failures like this."),"\n",t.createElement(a.h2,{id:"a-real-life-example",style:{position:"relative"}},"A Real Life Example",t.createElement(a.a,{href:"#a-real-life-example","aria-label":"a real life example permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"The ",t.createElement(a.a,{href:"https://github.com/WordPress/gutenberg"},"WordPress Gutenberg")," project is the block editor powering millions of WordPress sites. It went through a major cleanup of unnecessary memoisation. They removed useCallback from multiple components because the function wasn't passed to any hook or memoised component that might require a stable reference."),"\n",t.createElement(a.p,null,"Here's a pattern similar to what they found - a block settings component:"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">BlockSettings</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onUpdate<span class="token punctuation">,</span> settings <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Unnecessary useCallback - passed to regular component</span>\n  <span class="token keyword">const</span> handleChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">onUpdate</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>settings<span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">:</span> value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>settings<span class="token punctuation">,</span> onUpdate<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SettingsPanel</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">TextControl</span></span>\n        <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token string">\'title\'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">}</span></span>\n      <span class="token punctuation">/></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToggleControl</span></span>\n        <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token string">\'visible\'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">}</span></span>\n      <span class="token punctuation">/></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">SettingsPanel</span></span><span class="token punctuation">></span></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"Spot the problem? üîç The TextControl and ToggleControl aren't memoized components. They're going to re-render whenever BlockSettings re-renders anyway. The useCallback achieves absolutely nothing here."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">BlockEditor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> block <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Another useCallback</span>\n  <span class="token keyword">const</span> handleUpdate <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">newSettings</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">updateBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>id<span class="token punctuation">,</span> newSettings<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>block<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// This creates a new object every render!</span>\n  <span class="token keyword">const</span> settings <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">title</span><span class="token operator">:</span> block<span class="token punctuation">.</span>title<span class="token punctuation">,</span>\n    <span class="token literal-property property">visible</span><span class="token operator">:</span> block<span class="token punctuation">.</span>visible<span class="token punctuation">,</span>\n    <span class="token literal-property property">layout</span><span class="token operator">:</span> block<span class="token punctuation">.</span>layout\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BlockSettings</span></span> <span class="token attr-name">settings</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>settings<span class="token punctuation">}</span></span> <span class="token attr-name">onUpdate</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleUpdate<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"Let's trace the cascade:"),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,t.createElement(a.strong,null,"settings object")," - Created fresh every render (new object reference)"),"\n",t.createElement(a.li,null,t.createElement(a.strong,null,"handleChange in BlockSettings")," - Depends on settings, so recreated every render despite useCallback"),"\n",t.createElement(a.li,null,t.createElement(a.strong,null,"handleUpdate in BlockEditor")," - Only stable if block.id doesn't change, but..."),"\n",t.createElement(a.li,null,t.createElement(a.strong,null,"settings breaks the chain")," - The moment settings is a new object, everything downstream fails"),"\n"),"\n",t.createElement(a.p,null,"Even though we have two useCallbacks, both are completely useless at this point because settings isn't memoised."),"\n",t.createElement(a.p,null,"The WordPress Gutenberg team's solution? They removed the unnecessary useCallbacks entirely. The code became simpler and more maintainable, with zero performance impact because the memoisation was never working anyway."),"\n",t.createElement(a.p,null,"This same pattern appears everywhere in React codebases - well-intentioned useCallbacks that achieve nothing because somewhere in the dependency chain, a new object or array is created. Let's take a look at better ways to handle this."),"\n",t.createElement(a.h2,{id:"escaping-the-dependency-trap",style:{position:"relative"}},"Escaping the Dependency Trap",t.createElement(a.a,{href:"#escaping-the-dependency-trap","aria-label":"escaping the dependency trap permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"The immediate goal is to stabilise an effect dependency and avoid breaking memoizations in our code; there are currently far better ways than always reaching for manual useCallback and useMemo. These methods will allow you to access the latest state/props inside an effect without forcing the effect to re-run."),"\n",t.createElement(a.h3,{id:"the-ref-pattern-",style:{position:"relative"}},"The Ref Pattern üéØ",t.createElement(a.a,{href:"#the-ref-pattern-","aria-label":"the ref pattern  permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"This pattern is pretty straightforward; it aims to solve our problem of using unstable references and causing the effect to re-run unnecessarily. What we do here is store the value we want to access in a ref, and update it on every render, that's it:"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">useDragHandlers</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">draggableId</span><span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">callbacks</span><span class="token operator">:</span> DragCallbacks</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Store callbacks in a ref</span>\n  <span class="token keyword">const</span> callbacksRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>callbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Update ref every render (cheap operation)</span>\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    callbacksRef<span class="token punctuation">.</span>current <span class="token operator">=</span> callbacks<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Handlers never change, but always use the latest callbacks</span>\n  <span class="token keyword">const</span> onDragStart <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    callbacksRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span>onStart<span class="token operator">?.</span><span class="token punctuation">(</span>draggableId<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>draggableId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Only draggableId in dependencies!</span>\n\n  <span class="token keyword">const</span> onDragEnd <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    callbacksRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span>onEnd<span class="token operator">?.</span><span class="token punctuation">(</span>draggableId<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>draggableId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>draggableId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    element<span class="token operator">?.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'mousedown\'</span><span class="token punctuation">,</span> onDragStart<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    element<span class="token operator">?.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'mouseup\'</span><span class="token punctuation">,</span> onDragEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      element<span class="token operator">?.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'mousedown\'</span><span class="token punctuation">,</span> onDragStart<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      element<span class="token operator">?.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'mouseup\'</span><span class="token punctuation">,</span> onDragEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>draggableId<span class="token punctuation">,</span> onDragStart<span class="token punctuation">,</span> onDragEnd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// These never change now</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> onDragStart<span class="token punctuation">,</span> onDragEnd <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Now consumers don\'t need ANY memoisation</span>\n<span class="token keyword">function</span> <span class="token function">DraggableCard</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> id<span class="token punctuation">,</span> onDragStart<span class="token punctuation">,</span> onDragEnd <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Just pass callbacks directly - no useMemo needed!</span>\n  <span class="token keyword">const</span> handlers <span class="token operator">=</span> <span class="token function">useDragHandlers</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">onStart</span><span class="token operator">:</span> onDragStart<span class="token punctuation">,</span>\n    <span class="token literal-property property">onEnd</span><span class="token operator">:</span> onDragEnd\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token spread"><span class="token punctuation">{</span><span class="token operator">...</span>handlers<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">Drag me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"The ref always points to the latest callbacks, the handlers never change, you've got stable dependencies!, and we've eliminated the entire fragile memoisation chain."),"\n",t.createElement(a.p,null,"Many popular component libraries use this pattern to avoid forcing consumers to memoise their callbacks. For example, ",t.createElement(a.a,{href:"https://headlessui.com/"},"Headless UI")," (by Tailwind Labs) and ",t.createElement(a.a,{href:"https://www.radix-ui.com/"},"Radix UI")," both store callback refs internally to ensure components work correctly regardless of whether users memoise their props. Imagine if these libraries required consumers to memoise their options manually, it would be a terrible developer experience."),"\n",t.createElement(a.h3,{id:"useeffectevent-",style:{position:"relative"}},"useEffectEvent üÜï",t.createElement(a.a,{href:"#useeffectevent-","aria-label":"useeffectevent  permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"React 19.2 recently introduced ",t.createElement(a.a,{href:"https://react.dev/reference/react/experimental_useEffectEvent"},"useEffectEvent"),", a hook that helps you separate non-reactive logic from effects, avoiding ",t.createElement(a.strong,null,"stale closures")," and unnecessary effect re-runs. In short, it's used when you need imperative access to the latest value of something during a reactive effect without explicitly forcing the effect to re-run. This is now the recommended solution for the pattern described above."),"\n",t.createElement(a.p,null,"Here's how you can refactor with useEffectEvent:"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">useDragHandlers</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">draggableId</span><span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">callbacks</span><span class="token operator">:</span> DragCallbacks</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// useEffectEvent handles callbacks that "aren\'t reactive"</span>\n  <span class="token keyword">const</span> handleDragStart <span class="token operator">=</span> <span class="token function">useEffectEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    callbacks<span class="token punctuation">.</span>onStart<span class="token operator">?.</span><span class="token punctuation">(</span>draggableId<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">const</span> handleDragEnd <span class="token operator">=</span> <span class="token function">useEffectEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    callbacks<span class="token punctuation">.</span>onEnd<span class="token operator">?.</span><span class="token punctuation">(</span>draggableId<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>draggableId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    element<span class="token operator">?.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'mousedown\'</span><span class="token punctuation">,</span> handleDragStart<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    element<span class="token operator">?.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'mouseup\'</span><span class="token punctuation">,</span> handleDragEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      element<span class="token operator">?.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'mousedown\'</span><span class="token punctuation">,</span> handleDragStart<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      element<span class="token operator">?.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'mouseup\'</span><span class="token punctuation">,</span> handleDragEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>draggableId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Only draggableId needed!</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">onDragStart</span><span class="token operator">:</span> handleDragStart<span class="token punctuation">,</span> <span class="token literal-property property">onDragEnd</span><span class="token operator">:</span> handleDragEnd <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,'This makes handleChange non-reactive; it always "sees" the latest values of onUpdate and settings, and it\'s referentially stable between renders. The best of all worlds, without having to write a single useless useCallback or useMemo.'),"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"For new code on React 19.2+:")," Use useEffectEvent instead of the Latest Ref pattern."),"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"For existing codebases or older React versions:")," The Latest Ref pattern remains a solid solution."),"\n",t.createElement(a.h3,{id:"when-should-you-use-usecallback-and-usememo-",style:{position:"relative"}},"When Should You Use useCallback and useMemo? ü§î",t.createElement(a.a,{href:"#when-should-you-use-usecallback-and-usememo-","aria-label":"when should you use usecallback and usememo  permalink",className:"gatsby-remark-autolink-header-anchor after"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}}))),"\n",t.createElement(a.p,null,"Now that you've seen the problems and solutions, here's a simple guide for evaluating the use of useCallback and useMemo in your code:"),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"Is the function passed to React.memo() component?")),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"If NO ‚Äî ‚ùå Don't use useCallback"),"\n",t.createElement(a.li,null,"If YES ‚Äî Continue to #2"),"\n"),"\n"),"\n",t.createElement(a.li,null,"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"Have you measured that the component is slow (>16ms render)?")),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"If NO ‚Äî ‚ùå Don't use useCallback"),"\n",t.createElement(a.li,null,"If YES ‚Äî Continue to #3"),"\n"),"\n"),"\n",t.createElement(a.li,null,"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"Are all dependencies stable (not props or changing frequently)?")),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"If NO ‚Äî ‚ö†Ô∏è Use useEffectEvent or Latest Ref pattern instead"),"\n",t.createElement(a.li,null,"If YES ‚Äî ‚úÖ useCallback is appropriate"),"\n"),"\n"),"\n",t.createElement(a.li,null,"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"Is this for a useEffect dependency?")),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"‚ö†Ô∏è Use useEffectEvent (React 19.2+) or Latest Ref pattern instead"),"\n"),"\n"),"\n"),"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"The key principle:"),' Don\'t memoise unless you can answer "yes" to: ',t.createElement(a.em,null,'"Will this actually prevent something expensive from happening?"')),"\n",t.createElement(a.p,null,"If you're unsure, don't memoise. It's easier to add optimisation later than to debug broken memoisation chains. Remember, the best code is simple code. Three unnecessary useCallbacks or useMemo are harder to maintain than zero."))}var o=function(n){void 0===n&&(n={});const{wrapper:a}=Object.assign({},(0,e.RP)(),n.components);return a?t.createElement(a,n,t.createElement(p,n)):p(n)};const c=n=>{const{data:a,children:s}=n;return t.createElement("div",null,"Post")};function l(n){return t.createElement(c,n,t.createElement(o,n))}},8453:function(n,a,s){s.d(a,{RP:function(){return p}});var e=s(6540);const t=e.createContext({});function p(n){const a=e.useContext(t);return e.useMemo(()=>"function"==typeof n?n(a):{...a,...n},[a,n])}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-posts-2025-you-dont-need-use-memo-index-mdx-1273d2ea48a4683f7d19.js.map